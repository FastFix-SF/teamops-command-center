import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { calculateDeadlinePressure, getTaskQuadrant, calculatePriorityScore } from '@/lib/priority'

/**
 * GET - Get morning focus items for a user
 * POST - Pin a new focus item
 * PUT - Update focus item (mark complete, update reminder)
 * DELETE - Remove a pinned item
 */

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url)
  const memberId = searchParams.get('memberId')
  const includeAutoGenerated = searchParams.get('auto') !== 'false'

  if (!memberId) {
    return NextResponse.json({ error: 'memberId required' }, { status: 400 })
  }

  // Get manually pinned items
  const pinnedItems = await prisma.pinnedFocusItem.findMany({
    where: {
      memberId,
      completed: false,
      OR: [
        { expiresAt: null },
        { expiresAt: { gt: new Date() } }
      ]
    },
    orderBy: { priority: 'asc' }
  })

  // If auto-generated items requested, build the morning focus list
  let autoItems: Array<{
    id: string
    focusType: string
    title: string
    description: string | null
    priority: number
    source: string
    taskId?: string
  }> = []

  if (includeAutoGenerated) {
    const now = new Date()
    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000)
    const in48Hours = new Date(now.getTime() + 48 * 60 * 60 * 1000)

    // 1. Client deadlines in next 48 hours
    const clientDeadlines = await prisma.task.findMany({
      where: {
        status: { not: 'DONE' },
        externalClientDeadline: { lte: in48Hours }
      },
      include: { owner: { select: { name: true } } },
      orderBy: { externalClientDeadline: 'asc' }
    })

    for (const task of clientDeadlines) {
      const dp = calculateDeadlinePressure(task.internalDeadline, task.externalClientDeadline)
      autoItems.push({
        id: `auto-client-${task.id}`,
        focusType: 'CLIENT_DEADLINE',
        title: task.title,
        description: `Deadline cliente en ${dp.daysRemaining} día(s) - ${task.owner.name}`,
        priority: 1,
        source: 'AUTO_GENERATED',
        taskId: task.id
      })
    }

    // 2. P0 / Flagged tasks
    const flaggedTasks = await prisma.task.findMany({
      where: {
        status: { not: 'DONE' },
        OR: [
          { priority: 'P0' },
          { flaggedImmediate: true }
        ]
      },
      include: { owner: { select: { name: true } } }
    })

    for (const task of flaggedTasks) {
      if (!autoItems.find(i => i.taskId === task.id)) {
        autoItems.push({
          id: `auto-flagged-${task.id}`,
          focusType: 'TASK',
          title: task.title,
          description: `Tarea prioritaria (${task.priority}) - ${task.owner.name}`,
          priority: 2,
          source: 'AUTO_GENERATED',
          taskId: task.id
        })
      }
    }

    // 3. Blocked tasks needing escalation
    const blockedTasks = await prisma.task.findMany({
      where: { status: 'BLOCKED' },
      include: { owner: { select: { name: true } } }
    })

    for (const task of blockedTasks) {
      autoItems.push({
        id: `auto-blocked-${task.id}`,
        focusType: 'BLOCKED_ESCALATION',
        title: `Desbloquear: ${task.title}`,
        description: task.blockerNotes || `Bloqueado por ${task.owner.name}`,
        priority: 3,
        source: 'AUTO_GENERATED',
        taskId: task.id
      })
    }

    // 4. Tasks due soon (internal)
    const dueSoon = await prisma.task.findMany({
      where: {
        status: { not: 'DONE' },
        internalDeadline: { gte: now, lte: in48Hours },
        externalClientDeadline: null // Not already in client deadlines
      },
      include: { owner: { select: { name: true } } }
    })

    for (const task of dueSoon) {
      if (!autoItems.find(i => i.taskId === task.id)) {
        const dp = calculateDeadlinePressure(task.internalDeadline, task.externalClientDeadline)
        autoItems.push({
          id: `auto-due-${task.id}`,
          focusType: 'TASK',
          title: task.title,
          description: `Vence en ${dp.daysRemaining} día(s) - ${task.owner.name}`,
          priority: 4,
          source: 'AUTO_GENERATED',
          taskId: task.id
        })
      }
    }

    // 5. Multi-hand tasks needing cross-check
    const multiHandTasks = await prisma.task.findMany({
      where: {
        status: { in: ['IN_PROGRESS', 'NOT_STARTED'] },
        requiresMultiHand: true
      },
      include: { owner: { select: { name: true } } },
      take: 5
    })

    for (const task of multiHandTasks) {
      if (!autoItems.find(i => i.taskId === task.id)) {
        autoItems.push({
          id: `auto-crosscheck-${task.id}`,
          focusType: 'CROSS_CHECK',
          title: `Cross-check: ${task.title}`,
          description: `Verificar con ${task.owner.name} (multi-hand)`,
          priority: 5,
          source: 'AUTO_GENERATED',
          taskId: task.id
        })
      }
    }
  }

  // Combine and deduplicate
  const allItems = [
    ...pinnedItems.map(p => ({
      ...p,
      isManual: true
    })),
    ...autoItems.map(a => ({
      ...a,
      isManual: false,
      memberId,
      completed: false,
      completedAt: null,
      remindAt: null,
      reminded: false,
      createdAt: new Date(),
      expiresAt: null
    }))
  ]

  // Sort by priority
  allItems.sort((a, b) => a.priority - b.priority)

  return NextResponse.json({
    items: allItems.slice(0, 10), // Limit to top 10
    stats: {
      total: allItems.length,
      manual: pinnedItems.length,
      auto: autoItems.length
    }
  })
}

export async function POST(req: NextRequest) {
  const data = await req.json()

  const item = await prisma.pinnedFocusItem.create({
    data: {
      memberId: data.memberId,
      taskId: data.taskId || null,
      focusType: data.focusType || 'CUSTOM',
      title: data.title,
      description: data.description || null,
      priority: data.priority || 1,
      source: 'MANUAL',
      remindAt: data.remindAt ? new Date(data.remindAt) : null,
      expiresAt: data.expiresAt ? new Date(data.expiresAt) : null
    }
  })

  // If task specified, also pin it on the task
  if (data.taskId) {
    await prisma.task.update({
      where: { id: data.taskId },
      data: { pinnedByManager: true }
    })
  }

  return NextResponse.json(item, { status: 201 })
}

export async function PUT(req: NextRequest) {
  const { id, ...data } = await req.json()

  const updateData: Record<string, unknown> = {}

  if (data.completed !== undefined) {
    updateData.completed = data.completed
    if (data.completed) {
      updateData.completedAt = new Date()
    }
  }

  if (data.reminded !== undefined) {
    updateData.reminded = data.reminded
  }

  if (data.priority !== undefined) {
    updateData.priority = data.priority
  }

  if (data.remindAt !== undefined) {
    updateData.remindAt = data.remindAt ? new Date(data.remindAt) : null
  }

  const item = await prisma.pinnedFocusItem.update({
    where: { id },
    data: updateData
  })

  return NextResponse.json(item)
}

export async function DELETE(req: NextRequest) {
  const { id, taskId } = await req.json()

  if (id) {
    await prisma.pinnedFocusItem.delete({ where: { id } })
  }

  // Also unpin from task if specified
  if (taskId) {
    await prisma.task.update({
      where: { id: taskId },
      data: { pinnedByManager: false }
    })
  }

  return NextResponse.json({ success: true })
}
